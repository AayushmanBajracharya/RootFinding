<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Root Finding Method & Comparison</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lucide/0.263.1/umd/lucide.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 24px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 32px;
      color: white;
    }

    .header h1 {
      font-size: 3rem;
      font-weight: bold;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    .header p {
      font-size: 1.25rem;
      opacity: 0.9;
    }

    .section {
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      border-radius: 20px;
      padding: 32px;
      border: 1px solid rgba(255,255,255,0.2);
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      margin-bottom: 32px;
      transition: transform 0.3s ease;
    }

    .section:hover {
      transform: translateY(-2px);
    }

    .section h2 {
      font-size: 1.75rem;
      font-weight: 600;
      color: #1f2937;
      margin-bottom: 24px;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .equation-input {
      max-width: 768px;
      margin: 0 auto;
    }

    .equation-input input {
      width: 100%;
      padding: 20px 24px;
      background: white;
      border: 3px solid #e5e7eb;
      border-radius: 15px;
      color: #1f2937;
      font-size: 1.25rem;
      transition: all 0.3s ease;
    }

    .equation-input input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
      transform: scale(1.02);
    }

    .examples {
      margin-top: 20px;
      color: #4b5563;
      text-align: center;
    }

    .examples p {
      font-weight: 500;
      margin-bottom: 12px;
    }

    .example-tags {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .example-tag {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.875rem;
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .example-tag:hover {
      transform: scale(1.05);
    }

    .methods-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 20px;
    }

    .method-btn {
      padding: 24px;
      border-radius: 15px;
      border: 3px solid #e5e7eb;
      background: white;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: relative;
      overflow: hidden;
    }

    .method-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    .method-btn:hover::before {
      left: 100%;
    }

    .method-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.15);
    }

    .method-btn span {
      font-weight: 600;
      font-size: 1.125rem;
      color: #1f2937;
    }

    .method-btn.selected {
      border-color: #667eea;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
    }

    .method-btn.selected span {
      color: white;
    }

    .method-indicator {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      transition: all 0.3s;
    }

    .blue { background-color: #3b82f6; }
    .green { background-color: #10b981; }
    .purple { background-color: #8b5cf6; }

    .compare-btn-container {
      text-align: center;
      margin-bottom: 40px;
    }

    .compare-btn {
      padding: 18px 40px;
      border-radius: 50px;
      font-weight: 600;
      font-size: 1.25rem;
      border: none;
      cursor: pointer;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 12px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
      position: relative;
      overflow: hidden;
    }

    .compare-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 12px 30px rgba(102, 126, 234, 0.4);
    }

    .compare-btn:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .loading {
      display: none;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #667eea;
      font-weight: 500;
      margin: 20px 0;
    }

    .loading.show {
      display: flex;
    }

    .spinner {
      width: 20px;
      height: 20px;
      border: 2px solid #e5e7eb;
      border-top: 2px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .results-section {
      display: none;
    }

    .results-section.show {
      display: block;
    }

    .results-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 24px;
      margin-bottom: 32px;
    }

    .result-card {
      background: white;
      border-radius: 15px;
      padding: 24px;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
      border-left: 5px solid;
      transition: transform 0.3s ease;
    }

    .result-card:hover {
      transform: translateY(-2px);
    }

    .result-card.bisection {
      border-left-color: #3b82f6;
    }

    .result-card.secant {
      border-left-color: #10b981;
    }

    .result-card.newton {
      border-left-color: #8b5cf6;
    }

    .result-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .result-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #1f2937;
    }

    .result-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 16px;
      margin-bottom: 20px;
    }

    .stat-item {
      text-align: center;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #1f2937;
    }

    .stat-label {
      font-size: 0.875rem;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .chart-container {
      position: relative;
      height: 300px;
      margin-top: 20px;
    }

    .expandable-section {
      border: 1px solid #e5e7eb;
      border-radius: 15px;
      overflow: hidden;
      background: white;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
      margin-bottom: 16px;
      transition: all 0.3s ease;
    }

    .expandable-section:hover {
      box-shadow: 0 8px 15px rgba(0,0,0,0.1);
    }

    .expandable-header {
      width: 100%;
      padding: 20px;
      background: white;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      transition: all 0.3s ease;
    }

    .expandable-header:hover {
      background: #f8fafc;
    }

    .expandable-content {
      max-height: 0;
      overflow: hidden;
      padding: 0 20px;
      transition: all 0.4s ease;
    }

    .expandable-content.show {
      max-height: 400px;
      padding: 20px;
    }

    .expandable-content p {
      line-height: 1.6;
      color: #4b5563;
    }

    .method-name {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .method-name span {
      font-weight: 600;
      font-size: 1.125rem;
    }

    .chevron {
      transition: transform 0.3s ease;
    }

    .chevron.rotated {
      transform: rotate(90deg);
    }

    .error-message {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #dc2626;
      padding: 16px;
      border-radius: 10px;
      margin-bottom: 20px;
      display: none;
    }

    .error-message.show {
      display: block;
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }

      .section {
        padding: 20px;
      }

      .methods-grid {
        grid-template-columns: 1fr;
      }

      .results-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header --> 
    <div class="header">
      <h1><i data-lucide="zap" class="chevron"></i> Root Finding Method & Comparison</h1>
      <p>Discover and compare powerful root finding methods with interactive visualizations</p>
    </div>

    <!-- Equation Input -->
    <div class="section">
      <h2><i data-lucide="function-square" class="chevron"></i> Enter Your Function</h2>
      <div class="equation-input">
        <input type="text" id="equationInput" placeholder="e.g., x^2 - 4" value="x^2 - 4" />
        <div class="examples">
          <p>Click to try examples:</p>
          <div class="example-tags">
            <span class="example-tag" onclick="setExample('x^2 - 4')">x² - 4</span>
            <span class="example-tag" onclick="setExample('x^3 - 2*x - 5')">x³ - 2x - 5</span>
            <span class="example-tag" onclick="setExample('cos(x) - x')">cos(x) - x</span>
            <span class="example-tag" onclick="setExample('exp(x) - 2')">eˣ - 2</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Method Selection -->
    <div class="section">
      <h2><i data-lucide="settings" class="chevron"></i> Select Methods to Compare</h2>
      <div class="methods-grid">
        <button class="method-btn selected" data-method="bisection">
          <span>Bisection Method</span>
          <div class="method-indicator blue"></div>
        </button>
        <button class="method-btn selected" data-method="secant">
          <span>Secant Method</span>
          <div class="method-indicator green"></div>
        </button>
        <button class="method-btn selected" data-method="newton">
          <span>Newton-Raphson Method</span>
          <div class="method-indicator purple"></div>
        </button>
      </div>
    </div>

    <!-- Compare Button -->
    <div class="compare-btn-container">
      <button class="compare-btn" id="compareBtn">
        <i data-lucide="play-circle"></i> Compare Methods
      </button>
      <div class="loading" id="loadingIndicator">
        <div class="spinner"></div>
        <span>Calculating roots...</span>
      </div>
    </div>

    <div class="error-message" id="errorMessage"></div>

    <!-- Results Section -->
    <div class="section results-section" id="resultsSection">
      <h2><i data-lucide="bar-chart-3" class="chevron"></i> Comparison Results</h2>
      <div class="results-grid" id="resultsGrid"></div>
    </div>

    <!-- Method Explanations -->
    <div class="section">
      <h2><i data-lucide="info" style="color: #f59e0b;"></i> Method Explanations</h2>

      <div class="expandable-section">
        <button class="expandable-header" data-method="bisection">
          <div class="method-name">
            <div class="method-indicator blue"></div>
            <span>Bisection Method</span>
          </div>
          <i data-lucide="chevron-right" class="chevron"></i>
        </button>
        <div class="expandable-content">
          <p>
            <strong>The Bisection Method</strong> is a robust root-finding algorithm that works by repeatedly bisecting an interval and selecting the subinterval where the function changes sign.<br><br>
            <strong>How it works:</strong><br>
            1. Start with an interval [a, b] where f(a) and f(b) have opposite signs<br>
            2. Calculate the midpoint c = (a + b) / 2<br>
            3. Evaluate f(c)<br>
            4. Replace either a or b with c, keeping the interval where the sign change occurs<br>
            5. Repeat until the interval is sufficiently small<br><br>
            <strong>Advantages:</strong> Always converges if initial conditions are met, simple to implement<br>
            <strong>Disadvantages:</strong> Slow convergence rate (linear), requires sign change in interval
          </p>
        </div>
      </div>

      <div class="expandable-section">
        <button class="expandable-header" data-method="secant">
          <div class="method-name">
            <div class="method-indicator green"></div>
            <span>Secant Method</span>
          </div>
          <i data-lucide="chevron-right" class="chevron"></i>
        </button>
        <div class="expandable-content">
          <p>
            <strong>The Secant Method</strong> uses two initial points to approximate the derivative and find the root using linear interpolation.<br><br>
            <strong>How it works:</strong><br>
            1. Start with two initial points x₀ and x₁<br>
            2. Draw a secant line through points (x₀, f(x₀)) and (x₁, f(x₁))<br>
            3. Find where this line intersects the x-axis: x₂ = x₁ - f(x₁) * (x₁ - x₀) / (f(x₁) - f(x₀))<br>
            4. Replace x₀ with x₁ and x₁ with x₂<br>
            5. Repeat until convergence<br><br>
            <strong>Advantages:</strong> Faster than bisection, doesn't require derivative calculation<br>
            <strong>Disadvantages:</strong> May not converge, sensitive to initial guesses
          </p>
        </div>
      </div>

      <div class="expandable-section">
        <button class="expandable-header" data-method="newton">
          <div class="method-name">
            <div class="method-indicator purple"></div>
            <span>Newton-Raphson Method</span>
          </div>
          <i data-lucide="chevron-right" class="chevron"></i>
        </button>
        <div class="expandable-content">
          <p>
            <strong>The Newton-Raphson Method</strong> uses the function's derivative to rapidly converge to the root using the tangent line approximation.<br><br>
            <strong>How it works:</strong><br>
            1. Start with an initial guess x₀<br>
            2. Calculate the tangent line at (x₀, f(x₀))<br>
            3. Find where this tangent intersects the x-axis: x₁ = x₀ - f(x₀) / f'(x₀)<br>
            4. Repeat with x₁ as the new guess<br>
            5. Continue until convergence<br><br>
            <strong>Advantages:</strong> Very fast convergence (quadratic), highly efficient when it works<br>
            <strong>Disadvantages:</strong> Requires derivative calculation, may fail if derivative is zero, sensitive to initial guess
          </p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Initialize Lucide icons
    lucide.createIcons();

    let selectedMethods = ['bisection', 'secant', 'newton'];
    let expandedMethod = null;

    const methods = {
      bisection: { name: 'Bisection Method', color: 'blue' },
      secant: { name: 'Secant Method', color: 'green' },
      newton: { name: 'Newton-Raphson Method', color: 'purple' }
    };

    const methodButtons = document.querySelectorAll('.method-btn');
    const compareBtn = document.getElementById('compareBtn');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const resultsSection = document.getElementById('resultsSection');
    const resultsGrid = document.getElementById('resultsGrid');
    const errorMessage = document.getElementById('errorMessage');
    const expandableHeaders = document.querySelectorAll('.expandable-header');

    // Function parser and evaluator
    function parseFunction(expr) {
      // Replace common mathematical expressions
      expr = expr.replace(/\^/g, '**');
      expr = expr.replace(/sin/g, 'Math.sin');
      expr = expr.replace(/cos/g, 'Math.cos');
      expr = expr.replace(/tan/g, 'Math.tan');
      expr = expr.replace(/exp/g, 'Math.exp');
      expr = expr.replace(/log/g, 'Math.log');
      expr = expr.replace(/sqrt/g, 'Math.sqrt');
      expr = expr.replace(/abs/g, 'Math.abs');
      expr = expr.replace(/pi/g, 'Math.PI');
      expr = expr.replace(/e/g, 'Math.E');
      
      return (x) => {
        try {
          return eval(expr.replace(/x/g, x));
        } catch (e) {
          throw new Error('Invalid function expression');
        }
      };
    }

    // Numerical derivative
    function derivative(f, x, h = 1e-8) {
      return (f(x + h) - f(x - h)) / (2 * h);
    }

    // Bisection method
    function bisectionMethod(f, a, b, tolerance = 1e-8, maxIterations = 100) {
      const start = performance.now();
      let iterations = 0;
      const steps = [];
      
      if (f(a) * f(b) > 0) {
        throw new Error('Function must have opposite signs at interval endpoints');
      }

      while (Math.abs(b - a) > tolerance && iterations < maxIterations) {
        const c = (a + b) / 2;
        const fc = f(c);
        
        steps.push({ x: c, fx: fc, interval: [a, b] });
        
        if (Math.abs(fc) < tolerance) {
          break;
        }
        
        if (f(a) * fc < 0) {
          b = c;
        } else {
          a = c;
        }
        
        iterations++;
      }
      
      const root = (a + b) / 2;
      const time = performance.now() - start;
      
      return {
        root,
        iterations,
        time,
        steps,
        precision: Math.abs(f(root))
      };
    }

    // Secant method
    function secantMethod(f, x0, x1, tolerance = 1e-8, maxIterations = 100) {
      const start = performance.now();
      let iterations = 0;
      const steps = [];
      
      while (iterations < maxIterations) {
        const fx0 = f(x0);
        const fx1 = f(x1);
        
        if (Math.abs(fx1 - fx0) < tolerance) {
          throw new Error('Division by zero in secant method');
        }
        
        const x2 = x1 - fx1 * (x1 - x0) / (fx1 - fx0);
        
        steps.push({ x: x2, fx: f(x2), x0, x1 });
        
        if (Math.abs(f(x2)) < tolerance || Math.abs(x2 - x1) < tolerance) {
          const time = performance.now() - start;
          return {
            root: x2,
            iterations,
            time,
            steps,
            precision: Math.abs(f(x2))
          };
        }
        
        x0 = x1;
        x1 = x2;
        iterations++;
      }
      
      throw new Error('Secant method did not converge');
    }

    // Newton-Raphson method
    function newtonRaphsonMethod(f, x0, tolerance = 1e-8, maxIterations = 100) {
      const start = performance.now();
      let iterations = 0;
      const steps = [];
      let x = x0;
      
      while (iterations < maxIterations) {
        const fx = f(x);
        const fpx = derivative(f, x);
        
        if (Math.abs(fpx) < tolerance) {
          throw new Error('Derivative is zero in Newton-Raphson method');
        }
        
        const x1 = x - fx / fpx;
        
        steps.push({ x: x1, fx: f(x1), derivative: fpx });
        
        if (Math.abs(f(x1)) < tolerance || Math.abs(x1 - x) < tolerance) {
          const time = performance.now() - start;
          return {
            root: x1,
            iterations,
            time,
            steps,
            precision: Math.abs(f(x1))
          };
        }
        
        x = x1;
        iterations++;
      }
      
      throw new Error('Newton-Raphson method did not converge');
    }

    // Create convergence chart
    function createConvergenceChart(canvasId, data, methodName, color) {
      const ctx = document.getElementById(canvasId).getContext('2d');
      
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: data.map((_, i) => i + 1),
          datasets: [{
            label: 'Root Approximation',
            data: data.map(step => step.x),
            borderColor: color,
            backgroundColor: color + '20',
            fill: true,
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            title: {
              display: true,
              text: `${methodName} Convergence`,
              font: { size: 14, weight: 'bold' }
            },
            legend: {
              display: false
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Iteration'
              }
            },
            y: {
              title: {
                display: true,
                text: 'Root Value'
              }
            }
          }
        }
      });
    }

    // Set example function
    function setExample(expr) {
      document.getElementById('equationInput').value = expr;
    }

    // Method selection logic
    methodButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const method = btn.dataset.method;
        
        if (selectedMethods.includes(method)) {
          selectedMethods = selectedMethods.filter(m => m !== method);
          btn.classList.remove('selected');
        } else {
          selectedMethods.push(method);
          btn.classList.add('selected');
        }
        
        updateCompareButton();
      });
    });

    // Expand/collapse logic
    expandableHeaders.forEach(header => {
      header.addEventListener('click', () => {
        const method = header.dataset.method;
        const content = header.nextElementSibling;
        const chevron = header.querySelector('.chevron');
        
        if (expandedMethod === method) {
          content.classList.remove('show');
          chevron.classList.remove('rotated');
          expandedMethod = null;
        } else {
          // Close all other expanded sections
          document.querySelectorAll('.expandable-content').forEach(c => c.classList.remove('show'));
          document.querySelectorAll('.expandable-header .chevron').forEach(c => c.classList.remove('rotated'));
          
          content.classList.add('show');
          chevron.classList.add('rotated');
          expandedMethod = method;
        }
      });
    });

    // Compare button logic
    compareBtn.addEventListener('click', async () => {
      const equation = document.getElementById('equationInput').value.trim();
      
      if (!equation) {
        showError('Please enter a function to analyze');
        return;
      }
      
      if (selectedMethods.length === 0) {
        showError('Please select at least one method');
        return;
      }
      
      hideError();
      showLoading();
      
      try {
        const f = parseFunction(equation);
        const results = {};
        
        // Run selected methods
        for (const method of selectedMethods) {
          try {
            switch (method) {
              case 'bisection':
                results[method] = bisectionMethod(f, -10, 10);
                break;
              case 'secant':
                results[method] = secantMethod(f, -1, 1);
                break;
              case 'newton':
                results[method] = newtonRaphsonMethod(f, 1);
                break;
            }
          } catch (error) {
            // Try different starting points for failed methods
            try {
              switch (method) {
                case 'bisection':
                  results[method] = bisectionMethod(f, -5, 5);
                  break;
                case 'secant':
                  results[method] = secantMethod(f, 0, 2);
                  break;
                case 'newton':
                  results[method] = newtonRaphsonMethod(f, 0);
                  break;
              }
            } catch (secondError) {
              results[method] = { error: error.message };
            }
          }
        }
        
        displayResults(results);
        
      } catch (error) {
        showError(`Error parsing function: ${error.message}`);
      } finally {
        hideLoading();
      }
    });

    function showLoading() {
      loadingIndicator.classList.add('show');
      compareBtn.disabled = true;
    }

    function hideLoading() {
      loadingIndicator.classList.remove('show');
      compareBtn.disabled = false;
    }

    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.classList.add('show');
    }

    function hideError() {
      errorMessage.classList.remove('show');
    }

    function updateCompareButton() {
      compareBtn.disabled = selectedMethods.length === 0;
    }

    function displayResults(results) {
      resultsGrid.innerHTML = '';
      
      Object.entries(results).forEach(([method, result]) => {
        const methodInfo = methods[method];
        const canvasId = `chart-${method}`;
        
        const resultCard = document.createElement('div');
        resultCard.className = `result-card ${method}`;
        
        if (result.error) {
          resultCard.innerHTML = `
            <div class="result-header">
              <div class="method-indicator ${methodInfo.color}"></div>
              <div class="result-title">${methodInfo.name}</div>
            </div>
            <div style="color: #dc2626; text-align: center; padding: 20px;">
              <i data-lucide="alert-circle" style="width: 24px; height: 24px; margin-bottom: 8px;"></i>
              <p>Method failed: ${result.error}</p>
            </div>
          `;
        } else {
          resultCard.innerHTML = `
            <div class="result-header">
              <div class="method-indicator ${methodInfo.color}"></div>
              <div class="result-title">${methodInfo.name}</div>
            </div>
            <div class="result-stats">
              <div class="stat-item">
                <div class="stat-value">${result.root.toFixed(6)}</div>
                <div class="stat-label">Root Found</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${result.iterations}</div>
                <div class="stat-label">Iterations</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${result.time.toFixed(2)}ms</div>
                <div class="stat-label">Time</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">${result.precision.toExponential(2)}</div>
                <div class="stat-label">Precision</div>
              </div>
            </div>
            <div class="chart-container">
              <canvas id="${canvasId}"></canvas>
            </div>
          `;
        }
        
        resultsGrid.appendChild(resultCard);
        
        // Create chart after element is added to DOM
        if (!result.error && result.steps.length > 0) {
          setTimeout(() => {
            const colors = {
              blue: '#3b82f6',
              green: '#10b981',
              purple: '#8b5cf6'
            };
            createConvergenceChart(canvasId, result.steps, methodInfo.name, colors[methodInfo.color]);
          }, 100);
        }
      });
      
      // Reinitialize Lucide icons for new elements
      lucide.createIcons();
      
      // Show results section
      resultsSection.classList.add('show');
      resultsSection.scrollIntoView({ behavior: 'smooth' });
    }

    // Initialize
    updateCompareButton();
  </script>
</body>
</html>